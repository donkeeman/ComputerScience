# 그래프 (Graph)
- **정점**(**Vertex**)과 두 정점을 연결하는 **간선**(**Edge**)으로 구성된 자료 구조
- **차수**: 하나의 정점에 근접하는 간선의 개수

## 널 그래프 (Null Graph)
- **간선이 없는** 그래프

## 무방향 그래프 (Undirected Graph)
- 간선에 **방향이 없는** 그래프
- ⓤ-----ⓥ 라면 정점 u에서 정점 v로 가는 경우, 정점 v에서 정점 u로 가는 경우 모두 가능
- 정점의 개수가 V일 때, **최대 간선의 수**는 **V * (V - 1) / 2** 개

## 방향 그래프 (Directed Graph)
- 간선에 **정해진 방향이 있는** 그래프
- ⓤ---->ⓥ 라면 정점 u에서 정점 v로 가는 경우만 가능, 정점 v에서 정점 u로 이동은 불가능
- 정점의 개수가 V일 때, **최대 간선의 수**는 **V * (V - 1)** 개

## 연결 그래프 (Connected Graph)
- 한 정점에서 다른 정점까지의 **경로가 존재하는** 그래프
- 모든 정점이 연결되지 않더라도 다른 정점을 거쳐서 가는 경우도 허용

### 강력 연결 그래프 (Strongly Connected Graph)
- 방향 그래프일 때 한 정점에서 다른 정점까지의 경로와 그 반대 경로가 **둘 다 존재**하는 그래프

## 단절 그래프 (Disconnected Graph)
- 한 정점에서 다른 정점까지의 **경로가 존재하지 않는** 그래프
- 경로가 하나라도 존재하지 않는다면 비연결 그래프

## 완전 그래프 (Complete Graph)
- **모든 정점**끼리 간선이 연결된 그래프
- **차수**는 **V - 1**
- 정점의 개수가 V일 때, **간선의 수**는 **V * (V - 1) / 2** 개

## 정규 그래프 (Regular Graph)
- 모든 정점의 **차수가 같은** 그래프

### K-정규 그래프 (K-Regular Graph)
- 모든 정점의 **차수**가 **K개**인 그래프
- 정점이 V개인 **완전 그래프**는 **(V - 1)-정규 그래프**

## 부분 그래프 (Sub Graph)
- 그래프에서 **일부** 정점과 간선만을 포함하는 그래프

## 가중 그래프 (Weighted Graph)
- 간선에 **가중치**가 부여된 그래프
- **다익스트라 알고리즘**(Dijkstra Algorithm)을 이용하여 **최소 비용의 경로**를 구할 수 있음

## 순환 그래프 (Cyclic Graph)
- 그래프 자체가 경로의 시작 정점과 끝 정점이 같은 경로, 즉 **사이클(Cycle)이 하나 이상 존재**하는 그래프
- **사이클 자체인 그래프** (Cycle Graph) 의 **차수**는 **2**

## 비순환 그래프 (Acyclic Graph)
- **사이클이 존재하지 않는** 그래프

### 방향성 비순환 그래프 (Directed Acyclic Graph)
- **방향** 그래프이면서 **사이클이 존재하지 않는** 그래프

## 인접 행렬 (Adjacency Matrix)
![image](https://user-images.githubusercontent.com/79434205/205628820-c9b8dd44-d42a-436d-ab68-c69f9f76230e.png)
- 정점의 개수가 V인 그래프를 V * V 크기의 **2차원 행렬**로 표현하는 방법
- 시작 정점을 행으로, 도착 정점을 열으로 표현
- **특정 정점에서 인접한 정점**이 몇 개인지 알고 싶을 때, 행렬 전체를 확인해야 하므로 걸리는 시간 복잡도는 **O(V)**
- **특정 정점과 정점이 연결**되어있는지 알고 싶을 때, 해당 원소만 확인하면 되므로 걸리는 시간 복잡도는 **O(1)**
- 차지하는 공간 복잡도는 **O(V^2)**
### 무방향 그래프의 경우
- 두 정점 사이에 간선이 **있다면** 원소는 **1**, 간선이 **없다면** 원소는 **0**
- ⓤ----ⓥ 라면 `matrix[u][v] = 1`, `matrix[v][u] = 1`
- **대칭 행렬**
### 방향 그래프의 경우
- 두 정점 사이에 간선이 **있다면** 원소는 **가중치**, 간선이 **없다면** 원소는 **0**
- 가중치가 0인 간선과 구분하기 위해 0 이외의 다른 값을 주는 경우도 있음
- ⓤ--2-->ⓥ 라면 `matrix[u][v] = 2`, `matrix[v][u] = 0`


## 인접 리스트 (Adjacency List)
![image](https://user-images.githubusercontent.com/79434205/205634049-34c97ef6-dba0-4fbb-8c84-1740edfff94b.png)
- 정점의 개수가 V, 간선의 개수가 E인 그래프를 정점 별로 인접한 정점들의 **연결 리스트**로 표현하는 방법
- 리스트의 순서에는 의미가 없음
- **특정 정점에서 인접한 정점**이 몇 개인지 알고 싶을 때, 해당 정점의 연결 리스트만 확인하면 되므로 걸리는 시간 복잡도는 **O(E)**
- **특정 정점과 정점이 연결**되어있는지 알고 싶을 때, 그 정점의 연결 리스트를 돌면서 확인해야 하므로 걸리는 시간 복잡도는 **O(V)**
- 차지하는 공간 복잡도는 **O(V + E)**
### 무방향 리스트의 경우
- 시작 정점의 리스트의 노드에 **도착 정점**을 저장
- 연결 리스트의 모든 길이의 합은 **2 * E**
- ⓤ----ⓥ, ⓤ----ⓦ 라면 `list[u] = [v, w]`, `list[v] = [u]`, `list[w] = [u]`
### 방향 그래프의 경우
- 시작 정점의 리스트의 노드에 **도착 정점**과 **가중치**를 저장
- 연결 리스트의 모든 길이의 합은 **E**
- ⓤ--2-->ⓥ, ⓤ--1-->ⓦ 라면 `list[u] = [[v, 2], [w, 1]]`

## 연산
- 정점 추가 ( **인접 행렬**의 경우 **O(V^2)**, **인접 리스트**의 경우 **O(1)** )
- 정점 삭제 ( **인접 행렬**의 경우 **O(V^2)**, **인접 리스트**의 경우 **O(V + E)** )
- 정점의 값 반환 및 설정
- 정점에 인접한 정점 목록 반환 ( **인접 행렬**의 경우 **O(V)**, **인접 리스트**의 경우 **O(E)** )
- 두 정점 사이에 간선이 존재하는지 체크 ( **인접 행렬**의 경우 **O(1)**, **인접 리스트**의 경우 **O(V)** )
- 두 정점 사이에 간선을 추가 ( **O(1)** )
- 두 정점 사이의 간선을 삭제 ( **인접 행렬**의 경우 **O(1)**, **인접 리스트**의 경우 **O(E)** )
- 두 정점 사이의 간선의 값 반환 및 설정

## 참고 사이트
- https://en.wikipedia.org/wiki/Graph_(abstract_data_type)
- https://www.geeksforgeeks.org/introduction-to-graphs-data-structure-and-algorithm-tutorials/
- http://www.ktword.co.kr/test/view/view.php?m_temp1=4843
- https://www.tutorialspoint.com/connected-vs-disconnected-graphs
- https://www.hackerearth.com/practice/notes/big-o-cheatsheet-series-data-structures-and-algorithms-with-thier-complexities-1/